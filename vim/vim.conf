" ----------------------------
" Plugins
" ----------------------------

set nocompatible             " be iMproved, required(Vundle)
filetype off                 " required(Vundle)

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

  Plugin 'VundleVim/Vundle.vim'          " Plugin manager

  Plugin 'kien/ctrlp.vim'                 " Fuzzy search
  Plugin 'bling/vim-airline'              " Status line
  Plugin 'lervag/vimtex'                  " latex support
  Plugin 'ap/vim-css-color'               " coloring RGB values
  Plugin 'morhetz/gruvbox'                " color scheme

  " cd ~/.vim/plugged/YouCompleteMe
  " python3 install.py --clangd-completer
  Plugin 'ycm-core/YouCompleteMe'         " autocompletion

call vundle#end()
filetype plugin indent on     "file type detection (Vundle required)


" ----------------------------
" General
" ----------------------------

" Sets how many lines of history VIM has to remember
set history=500

" auto read when a file is changed from the outside
set autoread

" copy to system clipboard
set clipboard=unnamedplus,unnamed

" Set 7 lines to the cursor when moving vertically
set so=7

" turn on the WiLd menu
set wildmenu

" ignore compiled files
set wildignore=*.o,*~,*.pyc,*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

" always show current position
set ruler

" allow to hide buffers even with unsaved changes
set hidden

" automatically wrap left and right when at the end
set whichwrap+=<,>,h,l

" ignore case when searching
set ignorecase

" become case sensitive if you type uppercase characters
set smartcase

" highlight search results
set hlsearch

" search as characters are entered
set incsearch

" don't redraw while executing macros (good performance config)
set lazyredraw

" show matching brackets
set showmatch

" No annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=

" Syntax highlighting
syntax enable
set background=dark

set encoding=utf8    " set utf8 as standard encoding and en_US as the standard language
set ffs=unix,dos,mac " use Unix as the standard file type

" turn backup off, since most stuff is in git anyway
set nobackup
set noswapfile

set expandtab      " turn a tab into spaces
set smarttab       " be smart when using tabs
set tabstop=2      " make tabs 2 spaces
set shiftwidth=2   " spaces for autoindents

" hilight tabs and trailing spaces
set list
set listchars=tab:-.,trail:.

set autoindent " on new lines, match indent of previous line

" hilight the row number of the current line
set cursorline
"hi CursorLine ctermbg=NONE cterm=NONE term=NONE
"hi CursorLineNr ctermfg=166 term=bold cterm=bold

" show line numbers
set number

" do not wrap lines
set nowrap

" show command in bottom bar
set showcmd

" visual autocomplete for command menu
set wildmenu

" matching bracket highlighting
set showmatch


set textwidth=80

" this makes the color after the textwidth column highlighted
set colorcolumn=+1

" load filetype-specific indent files
filetype indent on

" enable filetype plugins
filetype plugin on

" Return to last edit position when opening files
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" treat .tpp files as C++ files
au BufEnter *.tpp :setlocal filetype=cpp

" set text width for Markdown and  TeX files
au BufRead,BufNewFile *.md setlocal textwidth=80
au BufRead,BufNewFile *.tex setlocal textwidth=80


" ----------------------------
" Bindings
" ----------------------------

" set leader to comma
let mapleader = ","
let g:mapleader = ","
let maplocalleader = ","

" fast saving
nmap <leader>w :w!<cr>

" trim trailing whitespace
noremap <leader>ws :call TrimWhitespace()<cr>

" reload files that have changed outside the editor
nnoremap <leader>rf :edit<cr>

" toggle line numbers
nnoremap <leader>n :set nu!<cr>

" toggle paste mode on and off
map <leader>pp :setlocal paste!<cr>

" disable highlight when <leader><cr> is pressed
map <silent> <leader><cr> :noh<cr>

" toggle spell checking
noremap <leader>ss :setlocal spell! spelllang=en_us<cr>

" Close the current buffer
map <leader>bd :Bclose<cr>:tabclose<cr>gT

" Close all the buffers
map <leader>ba :bufdo bd<cr>

"map <leader>l :bnext<cr>
"map <leader>h :bprevious<cr>

" execute current file
nnoremap <leader>ef :!%:p<Enter>

" switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>:pwd<cr>

" format C/C++ code
map <leader>f :call ClangFormat()<cr>

" --- YouCompleteMe ---
"
" don't seek confirmation every time ycm_conf file is found
let g:ycm_confirm_extra_conf = 0

" go to definition of variable/type/function under cursor
nnoremap <leader>g  ::YcmCompleter GoTo<CR>

" print type of symbol under the cursor
nnoremap <leader>t  ::YcmCompleter GetType<CR>

" refactor the name under the cursor
nnoremap <leader>r  ::YcmCompleter RefactorRename<space>

" better symbol for errors and warnings
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'

" --- vimtex ---
"
let g:tex_flavor = 'latex'
let g:vimtex_view_general_viewer = 'okular'
let g:vimtex_view_general_options = '--unique file:@pdf\#src:@line@tex'
let g:vimtex_view_general_options_latexmk = '--unique'
let g:vimtex_compiler_latexmk = {
      \ 'options' : [
      \   '-pdf',
      \   '-silent',
      \   '-file-line-error',
      \   '-synctex=1',
      \   '-interaction=nonstopmode',
      \ ]}
" '-verbose',
" '-lualatex',

" --- ctrlp ---
"
let g:ctrlp_custom_ignore = 'build\|git'


" --- gruvbox ---
"
colorscheme gruvbox
let g:gruvbox_contrast = 'soft'

" ----------------------------
" Functions
" ----------------------------

" Use with :call TrimWhitespace()
fun! TrimWhitespace()
    let l:save = winsaveview()
    keeppatterns %s/\s\+$//e
    call winrestview(l:save)
endfun

" Format C/C++ code with clang-format
fun! ClangFormat()
    let l:save = winsaveview()
    keeppatterns %!clang-format -style=file
    call winrestview(l:save)
endfun

" Don't close window, when deleting a buffer
command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction

